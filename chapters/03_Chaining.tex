\chapter{Chaining}\label{chap:chaining}

The \Oper{chain} operation, also known as \Oper{scan} in some circles, is a
list operation where a function is applied successively to elements of a list
and the results are stored in a new list.
\[ \text{\Oper{chain}} \colon (a \times b \to a) \to a \to b \; \List \to a \; \List \]
The operation is similar to the
\Oper{right-fold} or \Oper{accumulate} operations, but instead of returning
only the result value, a list of the partial results is returned. As a function
in ML, \Oper{chain} could be written
\begin{lstlisting}[language=ML, style=Inline]
fun chain f z []      = []
  | chain f z (x::ls) = f (z,x) :: chain f (f (z,x)) ls;
\end{lstlisting}
The \Oper{chain} function is a higher-level function, taking a function
$f$ as its first argument. The second argument $z$ is the initial value or
\emph{initialization vector}. The last argument is the list. The function
$f$ is applied to each element in the list and the current $z$, and the
result is stored in the list and passed as the new initialization vector
for the tail.

\begin{Example}
We can combine \Oper{chain} with addition, in
    which case we get partial sums.
    \begin{lstlisting}[language=ML, style=Inline]
- chain (op +) 0 [1, 2, 3, 4];
> val it = [1, 3, 6, 10] : int list
    \end{lstlisting}
\end{Example}

Since we are dealing with first order theorems, we will usually consider
\Oper{chain} as an un-curried function with a fixed function $f$.

\section{Cipher Block Chaining}\label{sec:cbc}

The technique of \emph{cipher block chaining} was invented in 1978 at
IBM~\cite{ehrsam1978message} and is currently used in the SSL and TLS
cryptographic protocols~\cite{rfc5246}. It is a mode of operation in which one
encrypts blocks of a message by masking the current block with the previous
encrypted block, then applying the block-level encryption function to the
result. This forces an attacker to decrypt all previous blocks before
decrypting a later block, preventing him or her from attacking individual
blocks in parallel.

Formally, if a message's plaintext contains blocks $[M_1, \dotsc, M_n]$, then
the ciphertext will contain blocks $[C_1, \dotsc, C_n]$ such that:
\begin{align*}
    C_1 &= e_k(M_1 \oplus IV) &
    C_{i+1} &= e_k(M_i \oplus C_i)
\end{align*}
where $e_k$ is a function for block-level encryption with a key $k$, $\oplus$
is XOR, and $IV$ is an initialization vector.

The block chaining operation can be seen as an instance of \Oper{chain}, where
the function is XOR. In later sections, we will use block chaining as a
motivating example of studying chaining in general.

\section{\texorpdfstring{$\BC$}{BC} Theory}\label{sec:bc-theory}
To study the chaining operation, we will create an equational theory $\BC$ such
that chaining is a model. Our theory will have two sorts, $\Elt$ and $\List$, and
the following signature:
\begin{align*}
    \Bc &\colon \Elt \times \List \to \List &
    \Cons &\colon \Elt \times \List \to \List \\
    \Ff &\colon \Elt \times \Elt \to \Elt &
    \Nil &\colon \List
\end{align*}

Here $\Bc$ is our chaining operator (\textbf{b}lock \textbf{c}hain), $\Ff$ is
the fixed function to be chained, and $\Cons$ and $\Nil$ are the standard list
constructors. We define $\BC$ to have the following two axioms:
\begin{align*}
    \Bc(\Ve{x}, \Nil) &\Equals{} \Nil \\
    \Bc(\Ve{x}, \Cons(\Ve{y}, \Vl{z}))
    &\Equals{} \Cons(\Ff(\Ve{y}, \Ve{x}), \Bc(\Ff(\Ve{y}, \Ve{x}), \Vl{z}))
\end{align*}
We can orient these rules from left to right to create a rewrite system
$R_\BC$:
\begin{align*}
    \Bc(\Ve{x}, \Nil) &\To{} \Nil \\
    \Bc(\Ve{x}, \Cons(\Ve{y}, \Vl{z}))
    &\To{} \Cons(\Ff(\Ve{y}, \Ve{x}), \Bc(\Ff(\Ve{y}, \Ve{x}), \Vl{z}))
\end{align*}

\begin{Lemma}
    The rewrite system $R_\BC$ is convergent.
\end{Lemma}
\begin{proof}
    It is straightforward that $R_\BC$ is confluent, because there are no
    critical pairs ($\Cons$ and $\Nil$ clash). To prove $R_\BC$ terminating,
    note that all terms have finite size and depth. The first rule removes an
    occurrence of $\Bc$ with each application and must terminate. The second
    preserves the size of the term, but increases the depth of an occurrence of
    $\Bc$. Eventually all occurrences of $\Bc$ will be lower than the
    occurrences of $\Cons$, so the rule must terminate. So $R_\BC$ is
    terminating and thus it is confluent.
\end{proof}

\section{Element Theory \texorpdfstring{$\FF$}{F}}\label{sec:elt-theory}

Since the original chaining operation is a higher-order function, we would like
some way to make $\Ff$ behave like different functions. We do this using an
equational theory $\FF$ called the \emph{element theory}. This theory defines
the function symbol $\Ff\colon \Elt \times \Elt \to \Elt$. A theory $\FF$ must
satisfy four conditions to be an element theory:
\begin{enumerate}[(i)]
    \item $\FF$ and $\BC$ are \emph{disjoint except for $\Ff$}, i.e.,
        $\Sig(\FF) \, \cap \, \Sig(\BC) \subseteq \{ \Ff \}$.
    \item $\FF$ is \emph{subterm-collapse-free in $\Ff$}, i.e., there is no
        term $t$ such that $\Root(t) = \Ff$ and $t \Equals{\FF} \Sub{t}{p}$ for
        $p \neq \Empty$.
    \item $\Ff$ is \emph{semicancellative}, i.e., if $\Ff(t_1, t_2)
        \Equals{\FF} \Ff(t_3, t_4)$, then $t_1 \Equals{\FF} t_3 \, \Iff \, t_2
        \Equals{\FF} t_4$.
    \item The $\FF$-unification problem is finitary.
\end{enumerate}
Note that the first condition does not preclude $\FF$ from using function
symbols in addition to $\Ff$. It just says those symbols cannot be $\Bc$,
$\Cons$, or $\Nil$.

\begin{Lemma}
    The trivial theory $\varnothing$ is an element theory.
\end{Lemma}
\begin{proof}
    The first condition is vacuously true, since the trivial theory has no
    signature. For the remaining conditions, recall that $t_1
    \Equals{\varnothing} t_2$ if and only if $t_1 = t_2$. Thus the second
    condition holds because a term cannot be identically equal to a proper
    subterm of itself. The third condition holds because if $\Ff(t_1, t_2)
    \Equals{\FF} \Ff(t_3, t_4)$, then by decomposition $t_1 \Equals{\FF} t_3$
    and $t_2 \Equals{\FF} t_4$. Finally, the fourth condition holds since
    unification modulo the empty theory is unitary.
\end{proof}

Let $E_\oplus$ be the following equational theory:
\begin{align*}
    x \oplus x &\Equals{} 0 \\
    x \oplus 0 &\Equals{} x \\
    x \oplus y &\Equals{} y \oplus x \\
    (x \oplus y) \oplus z &\Equals{} x \oplus (y \oplus z)
    \intertext{One model for $E_\oplus$ is bits under exclusive OR. Now let
    $\FF_\oplus$ be $E_\oplus$ with the following additional axiom:}
    \Ff(x, y) &\Equals{} e(x \oplus y)
\end{align*}

\begin{Lemma}
    The theory $\FF_\oplus$ is an element theory.
\end{Lemma}
\begin{proof}
    The first condition clearly holds, since $\Sig(\FF_\oplus) = \{ e, \Ff,
    \oplus, 0 \}$. For the second condition, note that every $\Ff$-rooted
    term is $\FF_\oplus$-equivalent to an $e$-rooted term, and $e$ is unintereted.

    To prove the third condition, consider terms $t_1$, $t_2$, $t_3$ and $t_4$
    such that
    \[\Ff(t_1, t_2) \Equals{\FF_\oplus} \Ff(t_3, t_4)\]
    % Suppose $\Ff$ is not semi-cancellative. Without loss
    % of generality, assume $t_1 \Equals{\FF_\oplus} t_3$ but $t_2 \not\Equals{\FF_\oplus} t_4$.
    Since $\Ff(t_1, t_2) \Equals{\FF_\oplus} e(t_1 \oplus t_2)$ and $\Ff(t_3,
    t_4) \Equals{\FF_\oplus} e(t_3 \oplus t_4)$, and since $e$ is an uninterpreted
    function symbol, we have that
    \[t_1 \oplus t_2 \Equals{\FF_\oplus} t_3 \oplus t_4\]
    There are then three possibilities for the terms:
    \begin{enumerate}[(i)]
        \item $t_1 \Equals{\FF_\oplus} t_3$ and $t_2 \Equals{\FF_\oplus} t_4$
        \item $t_1 \Equals{\FF_\oplus} t_2$ and $t_3 \Equals{\FF_\oplus} t_4$
        \item $t_1 \Equals{\FF_\oplus} t_4$ and $t_2 \Equals{\FF_\oplus} t_3$
    \end{enumerate}
    Suppose, without loss of generality, that $t_1 \Equals{\FF_\oplus} t_3$. In the
    first case, we have immediately that $t_2 \Equals{\FF_\oplus} t_4$. In the
    second and third cases, by transitivity of $\Equals{\FF_\oplus}$, we find that
    \[t_1 \Equals{\FF_\oplus} t_2 \Equals{\FF_\oplus} t_3 \Equals{\FF_\oplus} t_4 \]
    and thus $t_2 \Equals{\FF_\oplus} t_4$.
\end{proof}

\section{Inductive Theory}\label{sec:inductive-theory}

\section{Cancellativity and Semicancellativity}\label{sec:cancel}

